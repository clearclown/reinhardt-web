# Part 2: Models and Database

In this tutorial, we'll set up a database and create our first models using Reinhardt's ORM layer, which is built on SeaQuery v1.0.0-rc1.

## Database Setup

Reinhardt supports multiple databases including PostgreSQL, MySQL, and SQLite. For this tutorial, we'll use SQLite for simplicity.

### Configuring the Database

First, add the database dependencies to `Cargo.toml`:

```toml
[dependencies]
reinhardt = { workspace = true, features = ["database", "orm"] }
tokio = { version = "1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
```

**Note**: Instead of adding `reinhardt-db` directly, we enable the `database` and `orm` features on the `reinhardt` crate. This provides access to all database functionality through `reinhardt::prelude::*`.

Create or update `settings/base.toml` with your database configuration:

```toml
debug = true
secret_key = "your-secret-key-for-development"

[database]
engine = "sqlite"
name = "polls.db"
```

**Note**: Reinhardt projects generated by `reinhardt-admin startproject` already include settings configuration. The database connection is automatically established when you run `cargo run --bin runserver`.

## Creating Models

A model is the single, definitive source of information about your data. It contains the essential fields and behaviors of the data you're storing.

Let's create two models for our polls application:

- **Question** - Stores poll questions with their publication date
- **Choice** - Stores choices for each question with their vote counts

Create `polls/models.rs`:

```rust
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use reinhardt::prelude::*;

#[derive(Debug, Clone, Serialize, Deserialize, Model)]
#[model(app_label = "polls", table_name = "polls_question")]
pub struct Question {
    #[field(primary_key = true)]
    pub id: Option<i64>,

    #[field(max_length = 200)]
    pub question_text: String,

    #[field(auto_now_add = true)]
    pub pub_date: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize, Model)]
#[model(app_label = "polls", table_name = "polls_choice")]
pub struct Choice {
    #[field(primary_key = true)]
    pub id: Option<i64>,

    #[field(foreign_key = "Question")]
    pub question_id: i64,

    #[field(max_length = 200)]
    pub choice_text: String,

    #[field(default = 0)]
    pub votes: i32,
}

impl Question {
    /// Check if this question was published recently (within the last day)
    pub fn was_published_recently(&self) -> bool {
        let now = Utc::now();
        let one_day_ago = now - chrono::Duration::days(1);
        self.pub_date >= one_day_ago && self.pub_date <= now
    }
}
```

These models define:

- **Question**: Has an auto-incrementing ID (Option<i64>), question text, and publication date
- **Choice**: Has an ID, references a Question (via `question_id`), choice text, and vote count

**Note**: `id` fields are `Option<i64>` because they're `None` before insertion and `Some(id)` after being saved to the database.

## Understanding Fields

Let's break down the field types:

- `Option<i64>` - Optional integer field for IDs (auto-generated)
- `i64` - Integer field for foreign keys
- `String` - Character field for text
- `DateTime<Utc>` - DateTime field for timestamps
- `i32` - Integer field for vote counts

### Field Attributes

The `#[field(...)]` attributes provide metadata for the ORM:

- `primary_key = true` - Marks the field as the primary key
- `max_length = 200` - Sets maximum length for string fields
- `auto_now_add = true` - Automatically sets timestamp on creation
- `default = 0` - Sets default value for the field
- `foreign_key = "ModelName"` - Defines a foreign key relationship

## Model Derive Macro Benefits

The `#[derive(Model)]` macro automatically generates:

1. **Type-Safe Field Accessors**: Access fields with type safety
   ```rust
   Question::field_id()           // Returns FieldRef<Question, Option<i64>>
   Question::field_question_text() // Returns FieldRef<Question, String>
   Question::field_pub_date()     // Returns FieldRef<Question, DateTime<Utc>>
   ```

2. **CRUD Methods**: Basic database operations
   ```rust
   question.save(&conn).await?;           // Insert or update
   question.delete(&conn).await?;         // Delete from database
   question.refresh_from_db(&conn).await?; // Reload from database
   ```

3. **QuerySet Methods**: Type-safe querying
   ```rust
   Question::objects()
       .filter(Question::field_pub_date().gte(Utc::now()))
       .all(&conn)
       .await?;
   ```

These methods are generated at compile time, providing zero-cost abstractions with full type safety.

## Creating the Database Schema with Migrations

Instead of manually creating SQL files, Reinhardt provides Django-style automatic migration generation:

```bash
cargo run --bin manage makemigrations
```

This command analyzes your models and automatically generates migration files in `migrations/polls/`. The generated migration will create tables with proper schema.

To apply the migrations:

```bash
cargo run --bin manage migrate
```

You should see output like:

```
Running migrations:
  Applying polls.0001_initial... OK
```

**What happened?**

1. `makemigrations` detected your `Question` and `Choice` models
2. Generated Rust migration code in `migrations/polls/_0001_initial.rs`
3. `migrate` applied these migrations to create the database tables

## Playing with the Database API

Now let's use Reinhardt's ORM to interact with the database. With `#[derive(Model)]`, many common operations are automatically available. Here are some examples:

### Creating Records

```rust
use reinhardt::prelude::*;
use chrono::Utc;

// Create a new question
let mut question = Question {
    id: None,
    question_text: "What's your favorite programming language?".to_string(),
    pub_date: Utc::now(),
};

// Save to database (generated by Model macro)
question.save(&conn).await?;
println!("Created question with ID: {:?}", question.id);
```

### Querying Records

```rust
// Get all questions ordered by publication date (using type-safe field accessors)
let questions = Question::objects()
    .order_by(Question::field_pub_date(), false)  // false = DESC
    .all(&conn)
    .await?;

// Filter questions by date
let recent_questions = Question::objects()
    .filter(Question::field_pub_date().gte(Utc::now() - chrono::Duration::days(7)))
    .all(&conn)
    .await?;

// Get a specific question by ID
let question = Question::objects()
    .filter(Question::field_id().eq(1))
    .first(&conn)
    .await?;
```

### Relationships

```rust
// Get all choices for a question
let choices = Choice::objects()
    .filter(Choice::field_question_id().eq(question.id.unwrap()))
    .all(&conn)
    .await?;
```

### Updating Records

```rust
// Update using F expressions (atomic database operations)
Choice::objects()
    .filter(Choice::field_id().eq(choice_id))
    .update()
    .set(Choice::field_votes(), F::new(Choice::field_votes()) + 1)
    .execute(&conn)
    .await?;
```

### Deleting Records

```rust
// Delete a record (generated by Model macro)
question.delete(&conn).await?;
```

### Custom Helper Methods

You can still add custom methods to your models:

```rust
impl Question {
    /// Check if this question was published recently (within the last day)
    pub fn was_published_recently(&self) -> bool {
        let now = Utc::now();
        let one_day_ago = now - chrono::Duration::days(1);
        self.pub_date >= one_day_ago && self.pub_date <= now
    }

    /// Get all choices for this question
    pub async fn choices(
        &self,
        conn: &DatabaseConnection
    ) -> Result<Vec<Choice>, Box<dyn std::error::Error>> {
        let question_id = self.id.ok_or("Question must be saved first")?;
        Choice::objects()
            .filter(Choice::field_question_id().eq(question_id))
            .all(conn)
            .await
    }
}
```

**Key Points:**
- `save()`, `delete()`, and `refresh_from_db()` are automatically generated by `#[derive(Model)]`
- Use `Model::objects()` to start building queries
- Use type-safe field accessors like `Question::field_id()` instead of string literals
- Use `F` expressions for atomic database updates (e.g., incrementing counters)

## Testing the Models

Let's create proper tests using rstest and TestContainers. First, add test dependencies to `Cargo.toml`:

```toml
[dev-dependencies]
rstest = "0.22"
testcontainers = "0.23"
tokio = { version = "1", features = ["full"] }
```

Create `polls/tests.rs`:

```rust
use super::models::{Question, Choice};
use reinhardt::prelude::*;
use reinhardt_test::fixtures::*;
use chrono::Utc;
use rstest::*;
use testcontainers::ContainerAsync;
use testcontainers_modules::postgres::Postgres;

#[fixture]
async fn postgres_db() -> (ContainerAsync<Postgres>, Arc<DatabaseConnection>) {
    let postgres = Postgres::default()
        .start()
        .await
        .expect("Failed to start PostgreSQL");

    let port = postgres.get_host_port_ipv4(5432).await.unwrap();
    let url = format!("postgres://postgres:postgres@localhost:{}/test_db", port);

    let conn = DatabaseConnection::connect(&url).await.unwrap();
    let conn = Arc::new(conn);

    // Run migrations
    run_migrations(&conn).await.unwrap();

    (postgres, conn)
}

#[rstest]
#[tokio::test]
async fn test_create_question_and_choices(
    #[future] postgres_db: (ContainerAsync<Postgres>, Arc<DatabaseConnection>)
) {
    let (_container, conn) = postgres_db.await;

    // Create a question
    let mut question = Question {
        id: None,
        question_text: "What's your favorite programming language?".to_string(),
        pub_date: Utc::now(),
    };

    question.save(&conn).await.unwrap();
    assert!(question.id.is_some());

    // Add some choices
    let question_id = question.id.unwrap();

    let mut rust_choice = Choice {
        id: None,
        question_id,
        choice_text: "Rust".to_string(),
        votes: 0,
    };
    rust_choice.save(&conn).await.unwrap();

    let mut python_choice = Choice {
        id: None,
        question_id,
        choice_text: "Python".to_string(),
        votes: 0,
    };
    python_choice.save(&conn).await.unwrap();

    // Retrieve the question
    let retrieved_question = Question::objects()
        .filter(Question::field_id().eq(question_id))
        .first(&conn)
        .await
        .unwrap()
        .expect("Question not found");

    assert_eq!(retrieved_question.question_text, question.question_text);
    assert!(retrieved_question.was_published_recently());

    // Get choices
    let choices = retrieved_question.choices(&conn).await.unwrap();
    assert_eq!(choices.len(), 2);

    // Container is automatically cleaned up when dropped
}

#[rstest]
#[tokio::test]
async fn test_increment_votes(
    #[future] postgres_db: (ContainerAsync<Postgres>, Arc<DatabaseConnection>)
) {
    let (_container, conn) = postgres_db.await;

    // Create question and choice
    let mut question = Question {
        id: None,
        question_text: "Test question".to_string(),
        pub_date: Utc::now(),
    };
    question.save(&conn).await.unwrap();

    let mut choice = Choice {
        id: None,
        question_id: question.id.unwrap(),
        choice_text: "Test choice".to_string(),
        votes: 0,
    };
    choice.save(&conn).await.unwrap();
    let choice_id = choice.id.unwrap();

    // Increment votes using F expression
    Choice::objects()
        .filter(Choice::field_id().eq(choice_id))
        .update()
        .set(Choice::field_votes(), F::new(Choice::field_votes()) + 1)
        .execute(&conn)
        .await
        .unwrap();

    // Verify votes incremented
    let updated_choice = Choice::objects()
        .filter(Choice::field_id().eq(choice_id))
        .first(&conn)
        .await
        .unwrap()
        .expect("Choice not found");

    assert_eq!(updated_choice.votes, 1);
}
```

**Key Testing Features:**

1. **rstest fixtures**: Reusable test setup with `#[fixture]`
2. **TestContainers**: Real PostgreSQL database for each test
3. **Automatic cleanup**: Containers are destroyed after tests
4. **Type-safe queries**: Using field accessors in assertions
5. **F expressions**: Testing atomic update operations

Run the test:

```bash
cargo test --package polls
```

## Using the ORM in Views

Now that we have models, let's use them in views. Update `polls/views.rs`:

```rust
use reinhardt::prelude::*;
use reinhardt_macros::endpoint;
use reinhardt_di::Depends;
use reinhardt_db::backends::DatabaseConnection;
use std::sync::Arc;
use crate::models::Question;

#[endpoint]
pub async fn index(
    #[inject] conn: Arc<DatabaseConnection>,
) -> Result<Response> {
    let questions = Question::all(&conn).await?;

    Response::ok()
        .with_json(&questions)
}

#[endpoint]
pub async fn detail(
    request: Request,
    #[inject] conn: Arc<DatabaseConnection>,
) -> Result<Response> {
    let question_id: i64 = request.path_params
        .get("question_id")
        .ok_or("Missing question_id")?
        .parse()?;

    let question = Question::get(&conn, question_id)
        .await?
        .ok_or("Question not found")?;

    let choices = question.choices(&conn).await?;

    let data = serde_json::json!({
        "question": question,
        "choices": choices,
    });

    Response::ok()
        .with_json(&data)
}
```

The `#[inject]` attribute automatically provides the database connection from the application's dependency injection container.

## Introduction to the Reinhardt Admin

The Reinhardt admin is an automatically-generated interface for managing your data. Let's enable it for our models.

Add the admin dependency to `Cargo.toml`:

```toml
[dependencies]
reinhardt = { version = "0.1.0-alpha.1", features = ["standard", "admin"] }
```

Register your models in `polls/admin.rs`:

```rust
use reinhardt_contrib::admin::ModelAdmin;
use crate::models::{Question, Choice};

pub fn register_admin(admin_site: &mut AdminSite) {
    admin_site.register::<Question>(ModelAdmin::default());
    admin_site.register::<Choice>(ModelAdmin::default());
}
```

The admin interface will be covered in more detail in Part 7, but for now, know that you can access it at `http://127.0.0.1:8000/admin/` after creating a superuser.

## Summary

In this tutorial, you learned:

- How to configure a database connection using settings files
- How to define models with Reinhardt's ORM
- How to use automatic migration generation (`makemigrations` and `migrate`)
- How to perform CRUD operations using QuerySet API
- How to use dependency injection to access the database in views
- The relationship between models (foreign keys)
- How to query the database using the ORM API (not raw SQL)

## What's Next?

Now that our models are set up, we can start building views that display this data to users. In the next tutorial, we'll create views that show poll questions and their details.

Continue to [Part 3: Views and URLs](3-views-and-urls.md).
