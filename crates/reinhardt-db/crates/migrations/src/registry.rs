//! Global Migration Registry
//!
//! This module provides a global registry for migrations using `linkme::distributed_slice`.
//! It enables automatic collection of migrations from across the codebase without
//! manual registration at runtime.
//!
//! # How it works
//!
//! 1. Use `collect_migrations!` macro to register migrations from your app
//! 2. The macro generates a `MigrationProvider` impl and registers it with the global registry
//! 3. Use `all_migrations()` or `migrations_for_app()` to retrieve registered migrations
//!
//! # Example
//!
//! ```rust,ignore
//! // In your app's migrations.rs
//! pub mod _0001_initial;
//! pub mod _0002_add_fields;
//!
//! reinhardt::collect_migrations!(
//!     app_label = "polls",
//!     _0001_initial,
//!     _0002_add_fields,
//! );
//!
//! // In your tests
//! use reinhardt_migrations::registry::all_migrations;
//!
//! let migrations = all_migrations();
//! assert!(!migrations.is_empty());
//! ```

use linkme::distributed_slice;

use crate::Migration;

/// Function type for migration providers.
///
/// Each provider function returns all migrations for a specific app.
pub type MigrationProviderFn = fn() -> Vec<Migration>;

/// Global registry of migration providers.
///
/// This slice is populated at link-time by `#[distributed_slice]` attributes
/// generated by the `collect_migrations!` macro.
#[distributed_slice]
pub static MIGRATION_PROVIDERS: [MigrationProviderFn];

/// Returns all registered migrations from all apps.
///
/// Migrations are collected from all registered providers and returned
/// in the order they were registered. Note that the order may vary
/// between builds, so you should sort migrations by their dependencies
/// before applying them.
///
/// # Example
///
/// ```rust,ignore
/// use reinhardt_migrations::registry::all_migrations;
///
/// let migrations = all_migrations();
/// for migration in &migrations {
///     println!("App: {}, Name: {}", migration.app_label, migration.name);
/// }
/// ```
pub fn all_migrations() -> Vec<Migration> {
	MIGRATION_PROVIDERS
		.iter()
		.flat_map(|provider| provider())
		.collect()
}

/// Returns migrations for a specific app label.
///
/// # Arguments
///
/// * `app_label` - The app label to filter by (e.g., "polls", "users")
///
/// # Example
///
/// ```rust,ignore
/// use reinhardt_migrations::registry::migrations_for_app;
///
/// let polls_migrations = migrations_for_app("polls");
/// assert!(polls_migrations.iter().all(|m| m.app_label == "polls"));
/// ```
pub fn migrations_for_app(app_label: &str) -> Vec<Migration> {
	all_migrations()
		.into_iter()
		.filter(|m| m.app_label == app_label)
		.collect()
}

/// Returns all unique app labels that have registered migrations.
///
/// # Example
///
/// ```rust,ignore
/// use reinhardt_migrations::registry::registered_app_labels;
///
/// let apps = registered_app_labels();
/// for app in apps {
///     println!("App with migrations: {}", app);
/// }
/// ```
pub fn registered_app_labels() -> Vec<String> {
	let mut labels: Vec<String> = all_migrations().into_iter().map(|m| m.app_label).collect();
	labels.sort();
	labels.dedup();
	labels
}

/// Returns the total count of registered migrations.
///
/// This is useful for quick validation that migrations are being registered.
pub fn migration_count() -> usize {
	MIGRATION_PROVIDERS
		.iter()
		.map(|provider| provider().len())
		.sum()
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn test_empty_registry_returns_empty_vec() {
		// Initially, the registry should have no migrations registered
		// unless other tests have registered them
		let migrations = all_migrations();
		// We can't assert empty because other tests may register migrations
		// Just verify the function doesn't panic
		let _ = migrations;
	}

	#[test]
	fn test_migrations_for_nonexistent_app_returns_empty() {
		let migrations = migrations_for_app("nonexistent_app_12345");
		assert!(migrations.is_empty());
	}

	#[test]
	fn test_registered_app_labels_no_duplicates() {
		let labels = registered_app_labels();
		let mut sorted = labels.clone();
		sorted.sort();
		sorted.dedup();
		assert_eq!(labels.len(), sorted.len());
	}
}
